"""Tests for the TermoWeb schedule card asset."""

from __future__ import annotations

import json
import shutil
import subprocess
from pathlib import Path

import pytest


def test_schedule_card_clears_cache_when_prog_missing() -> None:
    """Ensure cached schedule data is dropped when prog disappears."""

    if shutil.which("node") is None:
        pytest.skip("Node.js runtime is required for schedule card tests")

    repo_root = Path(__file__).resolve().parents[1]
    card_path = repo_root / "custom_components" / "termoweb" / "assets" / "termoweb_schedule_card.js"
    card_path_str = json.dumps(str(card_path))

    script_lines = [
        "const fs = require('fs');",
        "const vm = require('vm');",
        f"const cardPath = {card_path_str};",
        "",
        "global.window = global;",
        "window.customCards = [];",
        "window.addEventListener = () => {};",
        "window.removeEventListener = () => {};",
        "window.requestAnimationFrame = (cb) => setTimeout(cb, 16);",
        "",
        "global.customElements = {",
        "  _registry: new Map(),",
        "  define(name, ctor) { this._registry.set(name, ctor); },",
        "  get(name) { return this._registry.get(name); },",
        "};",
        "",
        "class Element {",
        "  constructor(tag = '') {",
        "    this.tagName = String(tag).toUpperCase();",
        "    this.children = [];",
        "    this.parentNode = null;",
        "    this.style = {};",
        "    this.dataset = {};",
        "    this.classList = { toggle() {}, add() {}, remove() {} };",
        "    this.textContent = '';",
        "    this.value = '';",
        "    this.hidden = false;",
        "    this._innerHTML = '';",
        "    this._idMap = new Map();",
        "    this.options = [];",
      "  }",
        "  set innerHTML(html) {",
        "    this._innerHTML = String(html);",
        "    this._idMap.clear();",
        "    const regex = /id=\\\"([^\\\"]+)\\\"/g;",
        "    let match;",
        "    while ((match = regex.exec(this._innerHTML)) !== null) {",
        "      const el = new Element();",
        "      el.id = match[1];",
        "      this._idMap.set(`#${el.id}`, el);",
        "    }",
        "  }",
        "  get innerHTML() { return this._innerHTML; }",
        "  appendChild(child) {",
        "    if (child) {",
        "      this.children.push(child);",
        "      child.parentNode = this;",
        "      if (this.tagName === 'SELECT' && !this.options.includes(child)) {",
        "        this.options.push(child);",
        "      }",
        "    }",
        "    return child;",
        "  }",
        "  append(...children) {",
        "    children.forEach((child) => this.appendChild(child));",
        "  }",
        "  add(child, index) {",
        "    if (this.tagName !== 'SELECT' || !child) return;",
        "    if (index == null || index >= this.options.length) {",
        "      this.options.push(child);",
        "    } else {",
        "      this.options.splice(index, 0, child);",
        "    }",
        "    child.parentNode = this;",
        "  }",
        "  remove(index) {",
        "    if (this.tagName === 'SELECT' && typeof index === 'number') {",
        "      if (index >= 0 && index < this.options.length) {",
        "        const [removed] = this.options.splice(index, 1);",
        "        if (removed) removed.parentNode = null;",
        "      }",
        "      return;",
        "    }",
        "    if (!this.parentNode) return;",
        "    this.parentNode.children = this.parentNode.children.filter((node) => node !== this);",
        "    this.parentNode = null;",
        "  }",
        "  querySelector(selector) { return this._idMap.get(selector) || null; }",
        "  querySelectorAll() { return []; }",
        "  addEventListener() {}",
        "  removeEventListener() {}",
        "  contains(target) {",
        "    if (target === this) return true;",
        "    return this.children.some((child) => typeof child.contains === 'function' && child.contains(target));",
        "  }",
        "};",
        "",
        "class ShadowRoot extends Element {",
        "  constructor() {",
        "    super('shadowroot');",
        "  }",
        "};",
        "",
        "global.HTMLElement = class {",
        "  constructor() {",
        "    this.children = [];",
        "  }",
        "  appendChild(child) {",
        "    if (child) {",
        "      this.children.push(child);",
        "      child.parentNode = this;",
        "    }",
        "    return child;",
        "  }",
        "  removeChild(child) {",
        "    this.children = this.children.filter((node) => node !== child);",
        "  }",
        "  attachShadow() {",
        "    this.shadowRoot = new ShadowRoot();",
        "    return this.shadowRoot;",
        "  }",
        "  addEventListener() {}",
        "  removeEventListener() {}",
        "};",
        "",
        "global.document = {",
        "  createElement(tag) { return new Element(tag); },",
        "  body: new Element('body'),",
        "  activeElement: null,",
        "};",
        "",
        "vm.runInThisContext(fs.readFileSync(cardPath, 'utf8'), { filename: cardPath });",
        "",
        "const Card = customElements.get('termoweb-schedule-card');",
        "const card = new Card();",
        "card._renderCalls = 0;",
        "card._config = { entity: 'climate.test' };",
        "card._entity = 'climate.test';",
        "",
        "card._render = function() {",
        "  this._renderCalls += 1;",
        "  const hasProg = Array.isArray(this._progLocal) && this._progLocal.length === 168;",
        "  if (this._els && this._els.warn) {",
        "    this._els.warn.hidden = hasProg;",
        "  }",
        "  this._hasRendered = true;",
        "};",
        "card._renderGridOnly = function() {};",
        "card._updateStatusIndicators = function() {};",
        "card._restorePresetFocusIfNeeded = function() {};",
        "card._syncEntityOptions = function() {};",
        "card._updateModeButtons = function() {};",
        "",
        "const validState = {",
        "  states: {",
        "    'climate.test': {",
        "      attributes: {",
        "        prog: Array(168).fill(1),",
        "        ptemp: [10, 15, 20],",
        "      },",
        "    },",
        "  },",
        "};",
        "card.hass = validState;",
        "const renderAfterValid = card._renderCalls;",
        "const afterValid = {",
        "  hasProg: Array.isArray(card._progLocal) && card._progLocal.length === 168,",
        "  warnText: card._els && card._els.warn ? card._els.warn.textContent : null,",
        "  renderCalls: renderAfterValid,",
        "};",
        "",
        "const invalidState = {",
        "  states: {",
        "    'climate.test': {",
        "      attributes: {",
        "        ptemp: [10, 15, 20],",
        "      },",
        "    },",
        "  },",
        "};",
        "",
        "card.hass = invalidState;",
        "",
        "const afterInvalid = {",
        "  progIsNull: card._progLocal === null,",
        "  dirtyProg: card._dirtyProg,",
        "  warnText: card._els && card._els.warn ? card._els.warn.textContent : null,",
        "  renderCalls: card._renderCalls,",
        "};",
        "",
        "const result = {",
        "  afterValid,",
        "  afterInvalid,",
        "};",
        "",
        "console.log(JSON.stringify(result));",
    ]

    script = "\n".join(script_lines)

    proc = subprocess.run(
        ["node", "-e", script],
        check=False,
        capture_output=True,
        text=True,
        cwd=repo_root,
    )

    assert proc.returncode == 0, proc.stderr
    stdout = proc.stdout.strip()
    assert stdout, "No output from Node test harness"
    data = json.loads(stdout)

    assert data["afterValid"]["hasProg"] is True
    assert data["afterValid"]["warnText"] == ""
    assert data["afterInvalid"]["progIsNull"] is True
    assert data["afterInvalid"]["dirtyProg"] is False
    assert data["afterInvalid"]["warnText"] == "This entity has no valid 'prog' (expected 168 ints)."
